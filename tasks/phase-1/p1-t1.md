# P1.T1: infra: Setup Local Development Environment with Docker Compose

**1. Rationale:**
A robust and consistent local development environment is critical for efficient microservices development. Docker Compose allows us to define and manage all necessary infrastructure services (databases, message queues, caching) as code, ensuring every developer has an identical setup and eliminating "it works on my machine" issues. This task establishes the foundational environment for all subsequent development.

**2. Goal:**
To create a `docker-compose.yml` file and associated configurations that orchestrate all essential infrastructure services for the SaaScript backend, enabling developers to spin up a fully functional local development environment with a single command.

**3. Detailed Steps:**
* **Step 1: Create a `docker-compose.yml` file in the monorepo root.**
    * This file will define services for:
        * PostgreSQL (primary database)
        * DynamoDB Local (NoSQL for user profiles/dynamic data)
        * Redis (caching and sessions)
        * RabbitMQ (task queuing/command bus)
        * Apache Kafka (event streaming)
        * Zookeeper (dependency for Kafka)
    * Ensure appropriate ports are exposed and volumes are used for data persistence where necessary.
    * Set up basic environment variables for each service (e.g., database credentials, default ports).
* **Step 2: Add a `.env` file for Docker Compose environment variables.**
    * Create a `.env` file in the same directory as `docker-compose.yml`.
    * Define variables like `POSTGRES_USER`, `POSTGRES_PASSWORD`, `REDIS_PORT`, `RABBITMQ_USER`, etc., and reference them in `docker-compose.yml`.
    * Add this `.env` file to your main repository's `.gitignore` to prevent committing sensitive information.
* **Step 3: Test the Docker Compose setup.**
    * Bring up all services using:
        ```bash
        docker compose up -d
        ```
    * Verify all containers are running correctly:
        ```bash
        docker compose ps
        ```
    * Bring down services after testing:
        ```bash
        docker compose down
        ```
* **Step 4: Document the setup.**
    * Update the `saascript.md` file (Project Overview) under the "Core Technologies" section to reflect the use of Docker Compose for local development.
    * Add a small section to the `README.md` of the main `saascript` repository's root, explaining how to bring up the local development environment using Docker Compose.

**4. Acceptance Criteria / Definition of Done:**
* [ ] A `docker-compose.yml` file is present in the monorepo root, defining all required infrastructure services (PostgreSQL, DynamoDB Local, Redis, RabbitMQ, Kafka, Zookeeper).
* [ ] An accompanying `.env` file is present for sensitive environment variables, and it is correctly ignored by Git.
* [ ] All defined services can be successfully brought up (`docker compose up -d`) and shut down (`docker compose down`) without errors.
* [ ] Data persistence is configured correctly for databases and message queues using volumes.
* [ ] The `saascript.md` (Project Overview) and the main `saascript` repository's `README.md` are updated with clear instructions and details about the Docker Compose setup.

**5. Dependencies / Pre-requisites:**
* Docker Desktop (or Docker Engine and Docker Compose CLI) must be installed on the local machine.

**6. AI Co-Pilot Role:**
* **Project Lead (Gemini VS Code):** Focus on providing comprehensive and accurate Docker Compose definitions for each service, ensuring correct port mappings, volume mounts, and network configurations. Emphasize the importance of the `.env` file for secrets.
* **Software Engineer (GitHub Copilot):** Generate the `docker-compose.yml` and `.env` content precisely as defined, and assist with adding the documentation updates to the relevant `README.md` files.

**7. Guidance for AI Co-Pilot (GitHub Copilot):**
* **File:** `docker-compose.yml` (create at monorepo root)
* **Action:** Generate Docker Compose definitions for:
    * **PostgreSQL:** Use `postgres:14-alpine`, expose port `5432`, mount a named volume for data. Set `POSTGRES_DB`, `POSTGRES_USER`, `POSTGRES_PASSWORD` from `.env`.
    * **Redis:** Use `redis:7-alpine`, expose port `6379`. Mount a named volume.
    * **RabbitMQ:** Use `rabbitmq:3-management-alpine`, expose ports `5672` (AMQP) and `15672` (management UI). Set `RABBITMQ_DEFAULT_USER`, `RABBITMQ_DEFAULT_PASS` from `.env`.
    * **Zookeeper:** Use `zookeeper:3.8.0`, expose `2181`.
    * **Kafka:** Use `bitnami/kafka:3.5.1`, expose `9092`. Depend on Zookeeper. Configure `KAFKA_CFG_ZOOKEEPER_CONNECT` and `KAFKA_CFG_LISTENERS`, `KAFKA_CFG_ADVERTISED_LISTENERS`.
    * **DynamoDB Local:** Use `amazon/dynamodb-local`, expose `8000`.

* **File:** `.env` (create at monorepo root)
* **Action:** Populate with placeholder values for:
    * `POSTGRES_DB=saascript_db`
    * `POSTGRES_USER=saascript_user`
    * `POSTGRES_PASSWORD=saascript_password`
    * `RABBITMQ_DEFAULT_USER=rabbit_user`
    * `RABBITMQ_DEFAULT_PASS=rabbit_password`
    * `KAFKA_BROKER_ID=1`
    * `KAFKA_CFG_ZOOKEEPER_CONNECT=zookeeper:2181`
    * `KAFKA_CFG_LISTENERS=PLAINTEXT://:9092`
    * `KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://localhost:9092`

* **File:** Monorepo root `.gitignore`
* **Action:** Add `.env` to `.gitignore`.

* **File:** `saascript.md` (Update the "Core Technologies" section)
* **Action:** Add a line under "Local Development Containerization" stating: "Implemented via `docker-compose.yml` in the monorepo root, orchestrating PostgreSQL, DynamoDB Local, Redis, RabbitMQ, Kafka, and Zookeeper."

* **File:** Main `saascript` repository's `README.md` (Update or add a new section)
* **Action:** Add a "Local Development Setup" section with instructions:
    * Prerequisite: Docker Desktop installed.
    * Steps: `cd /path/to/saascript-repo`
    * `docker compose up -d` (to start services)
    * `docker compose down` (to stop services)
    * Briefly list the services started.